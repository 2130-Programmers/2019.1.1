// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2130.PlusAlpha.subsystems;

import org.usfirst.frc2130.PlusAlpha.Robot; 
import org.usfirst.frc2130.PlusAlpha.RobotMap;
import org.usfirst.frc2130.PlusAlpha.commands.*;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.DoubleSolenoid.Value;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.VictorSP;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class IntakeSubsystem extends Subsystem {
	
	public int x;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final DigitalInput infraredSensor = RobotMap.intakeSubsysteminfraredSensor;
    private final DoubleSolenoid intakeSol = RobotMap.intakeSubsystemintakeSol;
    private final SpeedController rightIntakeMotor = RobotMap.intakeSubsystemrightIntakeMotor;
    private final SpeedController leftIntakeMotor = RobotMap.intakeSubsystemleftIntakeMotor;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new IntakeProcedure());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    
    /* This case function allows for easier programming of the robot's pnuematics. "Closed" sets the arms to clamp on a
     * cube, "open" sets the arms to go around a cube so that we can clamp or drop it, and "neutral" empties out the cylinder
     * for our intake and firing routines. */
    public void clawPosition(String position) {
    	switch(position) {
    	case("closed"):
    		intakeSol.set(Value.kForward);
    	break;
    	case("open"):
    		intakeSol.set(Value.kReverse);
    	break;
    	case("neutral"):
    		intakeSol.set(Value.kOff);
    	break;
    	}
    }
    
    public void stopMotors() {
    	leftIntakeMotor.set(0);
    	rightIntakeMotor.set(0);
    }
    
    public void neutralClaw() {
    	clawPosition("neutral");
    }
    
    public void openClaw() {
    	clawPosition("open");
    }
    
    /* When running the cube intake function below, we were have a weird error where its default state, "closed", wasn't
     * allowing the pnuematics to fill, because the piston needed to be in the "neutral" position for the first 20 PSI, give or 
     * take. As such, this keeps the piston in its "neutral" position until I show that I need to use it by pulling
     * one of the triggers on the driver joystick */
    public void intakeInitializer() {
    	switch (x) {
    	case(0):
    		clawPosition("neutral");
    		
    		if (Robot.oi.driverJoystick.getRawAxis(2) == 1 || Robot.oi.driverJoystick.getRawAxis(3) == 1) {
        		x = 1;
        	}
    		break;
    	case(1):
    		cubeIntake();
    		break;
    	}
    }
    
    /* Sets x to 0 each time that teleop is called, which keeps the switch up there ^ from getting out of whack */
    public void zeroX() {
    	x = 0;
    }
  
    /* This is a fully automated cube intake. When neither of the triggers are fully depressed, the pnuematics go to
     * the "closed" position. This prevents excessive movement of the intake arms while driving, and allows for an instantaneous
     * clamp on the cube as soon as I see that its within our arms. It sets the system to "neutral" when we fire or 
     * intake the cube, allowing movement within the arms in either direction */
    public void cubeIntake() {
    	if (Robot.oi.driverJoystick.getRawAxis(2) == 1 && Robot.oi.driverJoystick.getRawAxis(3) < 1) {
    		leftIntakeMotor.set(0.9);  // "+" values intake the cube, while "-" values fire the cube
    		rightIntakeMotor.set(0.9);
    		
    		clawPosition("neutral");
    	}
    	
    	if (Robot.oi.driverJoystick.getRawAxis(2) < 1 && Robot.oi.driverJoystick.getRawAxis(3) < 1) {
    		leftIntakeMotor.set(0);
    		rightIntakeMotor.set(0);
    		
    		clawPosition("closed");
    	}
    	
    	if (Robot.oi.driverJoystick.getRawAxis(2) == 1 && Robot.oi.driverJoystick.getRawAxis(3) == 1) {
    		leftIntakeMotor.set(0);
    		rightIntakeMotor.set(0);
    		
    		clawPosition("neutral");
    	}
    	
    	if (Robot.oi.driverJoystick.getRawAxis(3) == 1 && Robot.oi.driverJoystick.getRawAxis(2) < 1) {
    		leftIntakeMotor.set(-1);
    		rightIntakeMotor.set(-1);
    		
    		clawPosition("closed");
    	}
    }
    
    /* This is a slow shot that corresponds to a different button on the controller than the normal loop above. I'll use
     * this function when I want to have a more delicate placement of the cube, such as an a full scale, where too much
     * speed could lead to tragic results */
    public void slowShot() {
    	clawPosition("neutral");
    	leftIntakeMotor.set(-0.5);
    	rightIntakeMotor.set(-0.5);
    }
    
    /* This is used during auto when we want to shoot the cube at full speed from our intake */
    public void fireCube() {
    	clawPosition("neutral");
    	leftIntakeMotor.set(-1);
    	rightIntakeMotor.set(-1);
    }
    
    /* This is used during auto when we want to drive forward while intaking, which will allow us to pick up a second cube and
     * potentially do two cubes in the 15 second period */
    public void autoIntakeProcedure() {
    	leftIntakeMotor.set(1);
    	rightIntakeMotor.set(1);
    }
    
}
