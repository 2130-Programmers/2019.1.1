// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2130.PlusAlpha.subsystems;

import java.util.Timer;

import org.usfirst.frc2130.PlusAlpha.Robot;  
import org.usfirst.frc2130.PlusAlpha.RobotMap;
import org.usfirst.frc2130.PlusAlpha.commands.*;
import edu.wpi.first.wpilibj.command.Subsystem;
import com.kauailabs.navx.frc.AHRS;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import edu.wpi.first.wpilibj.DoubleSolenoid.Value;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.ctre.phoenix.motorcontrol.can.WPI_VictorSPX;
import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.SpeedControllerGroup;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class DrivetrainSubsystem extends Subsystem {

	/* One Talon will in theory be able to run up to three PID loops, depending on the slot function that is below.
	 * Currently it is running the default PID slot, PID [0], but there will also be slot 1 and 2 in the future */
	public static final int kSlotIdx = 0;
	/* This will tell the Talon which PID slot to run, in this case selecting the one in slot 0 */
	public static final int kPIDLoopIdx = 0;
	/* The timeout portion of code keeps it from running in a constant loop and getting nowhere. If the code hasn't
	 * done anything during the "timeout" portion, it'll cancel the whole line and throw out an error */
	public static final int kTimeoutMs = 10;
	
	public double resultant;
	public double errorPrevious = 0;
	public int dataValue;
	private boolean ohCrap = false;
	
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
	private final String gameData = RobotMap.elevatorGameData;
	private final AHRS ahrs = RobotMap.drivetrainSubsystemahrs;
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final WPI_TalonSRX lRMotor = RobotMap.drivetrainSubsystemLRMotor;
    private final WPI_VictorSPX lFMotor = RobotMap.drivetrainSubsystemLFMotor;
    private final SpeedControllerGroup leftSideMotors = RobotMap.drivetrainSubsystemleftSideMotors;
    private final WPI_TalonSRX rRMotor = RobotMap.drivetrainSubsystemRRMotor;
    private final WPI_VictorSPX rFMotor = RobotMap.drivetrainSubsystemRFMotor;
    private final SpeedControllerGroup rightSideMotors = RobotMap.drivetrainSubsystemrightSideMotors;
    private final DifferentialDrive differentialDrive = RobotMap.drivetrainSubsystemdifferentialDrive;
    private final DoubleSolenoid shiftingSol = RobotMap.drivetrainSubsystemshiftingSol;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    public double iGenerator = 0;
    
    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new JoystickDrivetrain());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    
    /** Sensor Feedback  and Functions **/
    
    public void desiredGear(String gear) {
    	switch(gear) {
    	case("high"):
    		shiftingSol.set(Value.kReverse);
    	break;
    	case("low"):
    		shiftingSol.set(Value.kForward);
    	break;
    	}
    }
    
    /* This converts the alliance position of the switch and the scale into case friendly integer values.
     * 0 is == to the left side of the field, 1 is == to the right side of the field. */
    public int getDataValueFromPosition(int position) {
    	dataValue = 1;
    	if(gameData.length() > 0) {
    		if(gameData.charAt(position) == 'L') {
    			dataValue = 0;
    		}
    	}
    	return dataValue;
    }
    
    /* This shows how many degrees our robot has changed from whatever heading it considers 0 degrees */
    public double ahrsAngle() {
    	return ahrs.getAngle();
    }
    
    /* This function tells us how far our robot has traveled in ticks */
    public double magEncoderDistance() {
    	return lRMotor.getSelectedSensorPosition(0);
    }
    
    /* The following is a mathematical conversion to go from to ticks to feet.
     * [sensor position * (wheel circumference in feet * PI) / Ticks in a full rotation] */
    public double distanceInFeet() {
    	return lRMotor.getSelectedSensorPosition(0)  * ((0.5 * Math.PI) / 4096);
    }
    
    /* This shows how fast our robot is moving using ticks per second */
    public double magEncoderSpeed() {
    	return lRMotor.getSelectedSensorVelocity(0);
    }
    
    /* This uses a value that I found mathematically to convert our speed reading from ticks per second to
     * RPM */
    public double drivetrainRPM() {
    	return magEncoderSpeed() / 6.5975;
    }
    
    /* This function runs to set all of the drivetrain sensors to zero, it should be run at the start
     * of each auto move forward and auto turn commands */
    public void zeroTheSensors() {
    	iGenerator = 0;
    	errorPrevious = 0;
    	lRMotor.setSelectedSensorPosition(0, kPIDLoopIdx, 0);
    	ahrs.reset();
    }
    
    /* We want to run this in every function. The Talons have a persistent memory towards these settings,
     * so setting their max speed to 50% will lead to a couple hours of confused troubleshooting if you don't go
     * and change it back to 100% */
    public void configMotorPeakOutput(double maxSpeed) {
    	rFMotor.configPeakOutputForward(maxSpeed, 0);
    	rFMotor.configPeakOutputReverse(-maxSpeed, 0);
    	rRMotor.configPeakOutputForward(maxSpeed, 0);
    	rRMotor.configPeakOutputReverse(-maxSpeed, 0);
    	lFMotor.configPeakOutputForward(maxSpeed, 0);
    	lFMotor.configPeakOutputReverse(-maxSpeed, 0);
    	lRMotor.configPeakOutputForward(maxSpeed, 0);
    	lRMotor.configPeakOutputReverse(-maxSpeed, 0);
    }
    
    /* This shows the number of seconds that a Talon should take to get to full speed, with 0 being the default.
     * Put this command in things like the joystick command to keep things from getting weird */
    public void configMotorRampRate(double rampRate) {
    	lFMotor.configOpenloopRamp(rampRate, 0);
    	lRMotor.configOpenloopRamp(rampRate, 0);
    	rFMotor.configOpenloopRamp(rampRate, 0);
    	rRMotor.configOpenloopRamp(rampRate, 0);
    }
   
    /** Gyroscope Based Auto Routines **/
    
    /* This is a turn controller that we will send all of our setpoints through, essentially a home-built
     * P loop */
    public double controller(double target) {
    	double tolerance = 2; // The robot will try to get within 3 degrees of the desired angle
    	double kP = 0.017; // The proportional gain of our P loop
    	//double kI = 0.0001;
    	double kD = 0.0000197;
    	
    	double dIteration = 0.02;
    	
    	//double iOutput;
    	double dOutput;
    	double error = (target - ahrsAngle());
    	
    	//iGenerator += (error * 0.1);
    	//iOutput = iGenerator * kI;
    	
    	dOutput = (error - errorPrevious) / dIteration;
    	
    	errorPrevious = error;
    	
    	if (Math.abs(error) > tolerance) {
    		return (error * kP) + dOutput * kD; //+ iOutput;
    	} else {
    		return 0.0;
    	}
    }
    
    public double motorOutputs() {
    	return lRMotor.getMotorOutputPercent();
    }
    
    public void setWithSaturate(double limitedOutput) {
    	lRMotor.set(limitedOutput);
    	lFMotor.set(limitedOutput);
    	rRMotor.set(limitedOutput);
    	rFMotor.set(limitedOutput);
    }
    
    public void turnTo(double turnAngle) {
    	setWithSaturate(controller(turnAngle));
    }
    
    /** Magnetic Encoder Based Auto Routine **/
    
    /*  */
    public void moveToPosition(double targetFeet) {
    	double resultantMultiple = (targetFeet / Math.abs(targetFeet));
    	double error;
    	double resultant;
    	double p = 0.21;
    	double pOutput;
    	double angleI = 0.00000035;
    	double iOutput;
    	double angle = ahrs.getAngle();
    	/* The final int in the following line is the number of feet that the robot will take to slow down
    	 * during our auto routines. We'll have a less violent stop if this is a larger number, but it will
    	 * add seconds to each routine */
    	double coastingFeet = (resultantMultiple * 6);
    	/* Target coast and Target ticks put our target feet and our coasting feet into native talon units,
    	 * so that our encoder can use them in its calculations */
    	double targetCoast = (coastingFeet/1.570796327) * 4096;
    	double targetTicks = (targetFeet/1.570796327) * 4096;
    	
    	error = targetTicks - magEncoderDistance();
    	resultant = (error / targetCoast);
    	    	
    	iGenerator += (error * 0.1);
    	iOutput = iGenerator * angleI;

    	if (Math.abs(magEncoderDistance()) < Math.abs(targetTicks)) {
    		/* In the following equation, [1 * resultant) + x], x is equal to the minimum
    		 * speed that our robot can be slowed down to. For instance, (1 * 0.002) + 0.35 = 0.352 */
    		differentialDrive.arcadeDrive((resultantMultiple * resultant) + (resultantMultiple * 0.4), (-angle*p + iOutput));
    	}
    	else {
    		differentialDrive.arcadeDrive(0, 0);
    	}
    }
    
    /** Teleop Functions **/
    
    /* This should not be read */
    public void ohCrapBeenPressed() {
    	ohCrap = true;
    }
    
    public void NvmAllGood() {
    	ohCrap = false;
    }
    
    /* There will be three different kinds of drive trains in this function depending on what we need. I figure
     * its easier to delete commands than having to rewrite this all the time */
    
    public void joystickDriveTrain() {    	
    	/*if (drivetrainRPM() < 240 || drivetrainRPM() > -240) {
    		desiredGear("low");
    	}
    	if (drivetrainRPM() > 300 || drivetrainRPM() < -300) {
    		desiredGear("high");
    	}*/
    	
    	double a = -.000000000165206;
    	double b = -.000006982731;
    	double c = 1;
    	double elevatorHeight;
    	double elevatorHeightSquared;
    	double newThrottleOutput;
    	double newTurnOutput;
    	
    	elevatorHeight = Robot.elevatorPIDSubsytem.elevatorHeight(); //Elevator Height
    	elevatorHeightSquared = Math.pow(elevatorHeight, 2); //Height Squared
    	
    	//Ax^2 + Bx + C wherein x = elevator height
    	resultant = (a * (elevatorHeightSquared)) + (b * elevatorHeight) + c;
    	    	
    	/* When we get above a certain height, the equation above will reduce our turn rate enough that it
    	 * makes it redundant to further reduce it (as a matter of fact, we lost our ability to turn). So once
    	 * the elevator gets above a certain we stop reducing it */
    	double turnScale;
    	if (elevatorHeight < 8000) {
    		turnScale = 0.8;
    	} else {
    		turnScale = 1;
    	}
    	
    	configMotorRampRate(0);
    	//configMotorPeakOutput(1);
    	
    	
    	/** Kiddie Drive : for when kids are driving the robot. Trust me, we need it **/ 
    	if(ohCrap == true) {
    		configMotorPeakOutput(0);
    	} else {
    		configMotorPeakOutput(1);
    	}
    	
    	
    	//differentialDrive.arcadeDrive(Robot.oi.driverJoystick.getRawAxis(1) * -1, 
    	//							  Robot.oi.driverJoystick.getRawAxis(4) * 0.8);
    	
    	/** Unaltered Drive : This will run without any other functions **/
    	//differentialDrive.arcadeDrive(Robot.oi.driverJoystick.getRawAxis(1) * -1,
		//		   					  Robot.oi.driverJoystick.getRawAxis(4) * turnScale);
    	
    	/** Elevator Drive : Slows down when the elevator goes up **/
    	differentialDrive.arcadeDrive(Robot.oi.driverJoystick.getRawAxis(1) * -resultant,
    								  Robot.oi.driverJoystick.getRawAxis(4) * 0.7);
    }
    
    /* Sets the output of the motors to 0 */
    public void stopAllMotors() {
    	lRMotor.stopMotor();
    	rRMotor.stopMotor();
    	lFMotor.stopMotor();
    	rFMotor.stopMotor();
    }
}
