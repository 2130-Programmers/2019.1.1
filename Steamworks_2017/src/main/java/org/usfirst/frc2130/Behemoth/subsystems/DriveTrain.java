// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2130.Behemoth.subsystems;

import org.usfirst.frc2130.Behemoth.RobotMap;
import org.usfirst.frc2130.Behemoth.commands.*;

import java.io.PipedWriter;

import org.usfirst.frc2130.Behemoth.Robot;

import edu.wpi.first.wpilibj.Compressor;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.DoubleSolenoid.Value;
import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.Victor;

import edu.wpi.first.wpilibj.command.PIDSubsystem;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;

/**
 *
 */
public class DriveTrain extends PIDSubsystem {
	
	public double differenceA, // We will take our robot's position via gyro at present time, and subtract
				  			   // that value from a desired set point. The resultant difference is assigned to the variable
				  			   // difference.
				  differenceB,
				  differenceC,
				  differenceD,
				  differenceE,
				  differenceF,
				  differenceG,
				  proA, // After we have calculated our difference from our desired headings, we will then multiply the value
				  		// by our "ap" variable, giving us a proportional rate of turn.
				  		// For example, 		120 - 100 = 20			40 * 0.4 = 0.8 or 80% motor power.
				  proB,
				  proC,
				  procD,
				  procE,
				  procF,
				  procG,
				  headingA = -59, // The desired headings that our robot is trying to reach using the gryo that is 
				  				  // attached to the roborio.
				  headingB = 60,
				  headingC = 250,
				  headingD = -57,
				  headingE = -60,
				  headingF = 300,
				  headingG = 300,
				  tolerance = 2, // The amount of error that the gyro considers acceptable. Under current conditions,
				  				 // it will consider any degree + or - 2 of its desired heading to be acceptable, and stop
				  				 // trying to reach said degree if is within the range.
				  ap = 0.4, // These are the values by which we divide the calculated differences in order to get proportional
				  			// decreases in power, based on distance from the target, for our motors.
				  bp = 0.05, // Number used as a scale factor in a PID calculator below.
				  kp = 0.001,
				  z = 1,
				  n,
				  encoderOutput;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final Encoder driveTrainEncoder = RobotMap.driveTraindriveTrainEncoder;
    private final Compressor compressor = RobotMap.driveTrainCompressor;
    private final DoubleSolenoid shiftingSol = RobotMap.driveTrainshiftingSol;
    private final SpeedController lFMotor = RobotMap.driveTrainLFMotor;
    private final SpeedController lRMotor = RobotMap.driveTrainLRMotor;
    private final SpeedController rFMotor = RobotMap.driveTrainRFMotor;
    private final SpeedController rRMotor = RobotMap.driveTrainRRMotor;
    private final RobotDrive robotDrive41 = RobotMap.driveTrainRobotDrive41;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // Initialize your subsystem here
    public DriveTrain() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
        super("DriveTrain", 0.01, 0.0, 0.0);
        setAbsoluteTolerance(15.0);
        getPIDController().setContinuous(false);
        LiveWindow.addActuator("DriveTrain", "PIDSubsystem Controller", getPIDController());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID

        // Use these to get going:
        // setSetpoint() -  Sets where the PID controller should move the system
        //                  to
        // enable() - Enables the PID controller.
    }

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new shiftToHighGear());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }

    protected double returnPIDInput() {
        // Return your input value for the PID loop
        // e.g. a sensor, like a potentiometer:
        // yourPot.getAverageVoltage() / kYourMaxVoltage;

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
        return driveTrainEncoder.pidGet();

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
    }

    public void usePIDOutput(double output) {
        // Use output to drive your system, like a motor
        // e.g. yourMotor.set(output);
/*
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
        lFMotor.pidWrite(output);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
    	*/
    	lFMotor.pidWrite(-output);
        lRMotor.pidWrite(-output);
        rRMotor.pidWrite(output);
        rFMotor.pidWrite(output);        
    }
    
    // Drive Train Encoder
    
    	// Returns the value of our encoder.
    	public int readTheEncoder() {
    		return driveTrainEncoder.get();
   		}
    
    	// Sets the value of our encoder to 0 every time that the robot is enabled. Doing this every time avoids any accidents
    	// that may occur.
    	public void resetTheEncoder() {
    		driveTrainEncoder.reset();
    	}
    
    // Drive Train Gyro
    
    	// When this is activated, the robot CAN NOT be moving. Upon running this command, the robot will consider
    	// the position it is facing to be its new position zero. 
    	public void resetTheGyro() {
    		RobotMap.gyro.reset();
    	}
    
    	// Returns the value of the gryo.
    	public double readTheGyro() {
    		return RobotMap.gyro.getAngle();
    	}
    
    // Motor Control Functions
    
    	// This returns the percent of power being output by the Victor in the front left of our drive train.
    	public double motorValue() {
    		return lFMotor.get() * -1;
    	}
    	
    	// Implements the above value and mirrors it to all of the other three Victors in the drive train. 
    	public void setOtherVictors() {
    		rRMotor.set(motorValue());
    		rFMotor.set(motorValue());
    		lRMotor.set(motorValue() * -1);
    	}
    
    	// Sets the drive train to full stop.
    	public void stopTheDriveTrain() {
    		lFMotor.stopMotor();
    		lRMotor.stopMotor();
    		rFMotor.stopMotor();
    		rRMotor.stopMotor();
    	}
    
    	// New to this year, we will be using handheld controllers for our drive. The left joystick is for throttle control,
    	// the right joystick handles our rate of turn.
    	public void joystickDriveTrain() {
    		robotDrive41.arcadeDrive(Robot.oi.driverJoy.getRawAxis(1), 
    				                 Robot.oi.driverJoy.getRawAxis(4));
    	}
    
    // Drivetrain Calculations For Auto
    
    	// For the following three commands, we subtract our current heading from our desired heading, and apply that value to the
    	// difference variable. 
    	public double calDifA() {
    		differenceA = readTheGyro() - headingA;
    		return differenceA;
    	}
    
    	public double calDifB() {
    		differenceB = readTheGyro() - headingB;
    		return differenceB;
    	}
    
    	public double calDifC() {
    		differenceC = readTheGyro() - headingC;
    		return differenceC;
    	}
    	public double calDifD() {
    		differenceD = readTheGyro() - headingD;
    		return differenceD;
    	}
    	public double calDifE() {
    		differenceE = readTheGyro() - headingE;
    		return differenceE;
    	}
    	public double calDifF() {
    		differenceF = readTheGyro() - headingF;
    		return differenceF;
    	}
    	public double calDifG() {
    		differenceG = readTheGyro() - headingG;
    		return differenceG;
     	}
    
    	// For the following three commands, we multiply the difference calculated above by "ap". This means that the closer we get to 
    	// our desired heading, the slower our robot will move, ensuring that we have a smooth rate of turn. This value will be 
    	// applied to the ProA, B, or C variable.
    	public double proportionalA() {
    		proA = calDifA() * ap;
    		return proA;
    	}
    
    	public double proportionalB() {
    		proB = calDifB() * ap;
    		return proB;
    	}
    
    	public double proportionalC() {
    		proC = calDifC() * ap;
    		return proC;
    	}
    	public double proportionalD() {
    		procD = calDifD() * ap;
    		return procD;
    	}
    	public double proportionalE() {
    		procE = calDifE() * ap;
    		return procE;
    	}
    	public double proportionalF() {
    		procF = calDifF() * ap;
    		return procF;
    	}
    	public double proportionalG() {
    		procG = calDifG() * ap;
    		return procG;
    	}
    
    // Drivetrain Gyro PID Calculator And Headings
    	
    // Note for Jake, if you're able to read through the code. Everything below here was the result of experimentation, and 
    // meshing other subsystems together. It isn't the recommended way of handling autonomous motion, though Victors made it difficult
    // to pursue other ventures. I've been reading about Talon MotionMagic control for the last week or so, and we'll be using that for
    // sure next year.

    	// This takes a given target, be it any of our headings, and subtracts that target
    	// from our current gyro heading. If this error is greater than our predefined tolerance for the error, it will
    	// multiply it by bp, and set that as the motor value. It will run the motor through the "P" portion of a PID loop.
    	public double controller(double target) {
    		double error = (target - readTheGyro());
    		if (Math.abs(error) > tolerance) {
    			return error * bp;
    		}
    		else {
    			return 0.0;
    		}
    	}
    	
    	// This sets the output of our robot and slows it down to about one-half of its speed, because a fast rate
    	// of turn could affect the accuracy of our gyro. 
    	public void setWithSaturate(double desiredOutput) {
    		double limitedOutput = desiredOutput;
    		limitedOutput = limitedOutput * -0.8;
    		rFMotor.set(limitedOutput);
    		rRMotor.set(limitedOutput);
    		lFMotor.set(limitedOutput);
    		lRMotor.set(limitedOutput);
    	}
    
    	// All three of the following commands are called throughout our autonomous code. They run all of the
    	// above calculations and find / hold headings. In order to change headings, simply change the int value for each
    	// heading above.
    	public void goToHeadingA() {
    		double desiredOutput = controller(headingA);
    		setWithSaturate(desiredOutput);
    	}
    
    	public void goToHeadingB() {
    		double desiredOutput = controller(headingB);
    		setWithSaturate(desiredOutput);
    	}
    
    	public void goToHeadingC() {
    		double desiredOutput = controller(headingC);
    		setWithSaturate(desiredOutput);
    	}
    	public void goToHeadingD() {
    		double desiredOutput = controller(headingD);
    		setWithSaturate(desiredOutput);
    	}
    	public void goToHeadingE() {
    		double desiredOutput = controller(headingE);
    		setWithSaturate(desiredOutput);
    	}
    	public void goToHeadingF() {
    		double desiredOutput = controller(headingF);
    		setWithSaturate(desiredOutput);
    	}
    	public void goToheadingG() {
    		double desiredOutput = controller(headingG);
    		setWithSaturate(desiredOutput);
    	}
    	
    // Auto Drive Routines
    	
    // Like I said above, this is the result of experimentation. This was the closest, quickest thing I could think of to replicate
    // motion profiling for autonomous control without running Talons on the drive train.

    	// For each move command below, the robot picks an encoder set point and moves towards it until it is several hundred ticks away.
    	// At this point the robot drops speed so as to avoid overshooting, and if it does, and moves back at an even slower speed to get
    	// as close as possible to the true set point. This is far from the fastest method, but it was adequate for what we needed.
    	public void moveA() {
    		double angle = RobotMap.gyro.getAngle();
    		if(Robot.driveTrain.readTheEncoder() < 1300) {
    			robotDrive41.drive(-0.7, -angle * kp);
    		}
    		if(Robot.driveTrain.readTheEncoder() < 1850 && Robot.driveTrain.readTheEncoder() > 1300) {
    			robotDrive41.drive(-0.3, -angle * kp);
    		}
    		if(Robot.driveTrain.readTheEncoder() > 1850 && Robot.driveTrain.readTheEncoder() < 2000) {
    			robotDrive41.drive(0, angle * kp);
    		}
    		if(Robot.driveTrain.readTheEncoder() > 2000) {
    			robotDrive41.drive(0.4, angle * kp);
    		} 
    		
    		
    		//robotDrive41.drive(-0.4, -angle*kp);
    	}
    	
    	public void moveB() {
    		double angle = RobotMap.gyro.getAngle();
    		if(Robot.driveTrain.readTheEncoder() < 2000) {
    			robotDrive41.drive(-0.8, -angle * kp);
    		}
    		if(Robot.driveTrain.readTheEncoder() > 1350 && Robot.driveTrain.readTheEncoder() < 2100) {
    			robotDrive41.drive(-0.4, -angle * kp);
    		}
    		if(Robot.driveTrain.readTheEncoder() > 2100) {
    			robotDrive41.drive(0.4, angle * kp);
    		}
    		if(Robot.driveTrain.readTheEncoder() > 2050 && Robot.driveTrain.readTheEncoder() < 2100) {
    			robotDrive41.drive(0, angle * kp);
    		}
    	}
    	
    	public void moveC() {
    		double angle = RobotMap.gyro.getAngle();
    		if(Robot.driveTrain.readTheEncoder() < 2900) {
    			robotDrive41.drive(-0.3, -angle * kp);
    		}
    		if(Robot.driveTrain.readTheEncoder() > 3150) {
    			robotDrive41.drive(0.3, angle * kp);
    		}
    		if(Robot.driveTrain.readTheEncoder() > 2900 && Robot.driveTrain.readTheEncoder() < 3150) {
    			robotDrive41.drive(0, angle * kp);
    		}
    	}
    	public void moveD() {
    		double angle = RobotMap.gyro.getAngle();
    		if(Robot.driveTrain.readTheEncoder() < 850) {
    			robotDrive41.drive(-0.8, -angle * kp);
    		}
    		if(Robot.driveTrain.readTheEncoder() > 850 && Robot.driveTrain.readTheEncoder() < 1520) {
    			robotDrive41.drive(-0.4, -angle * kp);
    		}
    		if(Robot.driveTrain.readTheEncoder() > 1620) {
    			robotDrive41.drive(0.4, angle * kp);
    		}
    		if(Robot.driveTrain.readTheEncoder() > 1520 && Robot.driveTrain.readTheEncoder() < 1620) {
    			robotDrive41.drive(0, angle * kp);
    		}
    	}
    	public void moveE() {
    		double angle = RobotMap.gyro.getAngle();
    		if(Robot.driveTrain.readTheEncoder() < 2580) {
    			robotDrive41.drive(-0.4, -angle * kp);
    		}
    		if(Robot.driveTrain.readTheEncoder() > 2680) {
    			robotDrive41.drive(0.3, angle * kp);
    		}
    		if(Robot.driveTrain.readTheEncoder() > 2580 && Robot.driveTrain.readTheEncoder() < 2680) {
    			robotDrive41.drive(0, angle * kp);
    		}
    	}
    	public void moveF() {
    		double angle = RobotMap.gyro.getAngle();
    		if(Robot.driveTrain.readTheEncoder() < 2900) {
    			robotDrive41.drive(-0.3, -angle * kp);
    		}
    		if(Robot.driveTrain.readTheEncoder() > 3150) {
    			robotDrive41.drive(0.3, angle * kp);
    		}
    		if(Robot.driveTrain.readTheEncoder() > 2900 && Robot.driveTrain.readTheEncoder() < 3150) {
    			robotDrive41.drive(0, angle * kp);
    		}

    	}
    	public void moveG() {
    		double angle = RobotMap.gyro.getAngle();
    		if(Robot.driveTrain.readTheEncoder() < 2900) {
    			robotDrive41.drive(-0.3, -angle * kp);
    		}
    		if(Robot.driveTrain.readTheEncoder() > 3150) {
    			robotDrive41.drive(0.3, angle * kp);
    		}
    		if(Robot.driveTrain.readTheEncoder() > 2900 && Robot.driveTrain.readTheEncoder() < 3150) {
    			robotDrive41.drive(0, angle * kp);
    		}

    	}
    	public void moveH() {
    		double angle = RobotMap.gyro.getAngle();
    		if(Robot.driveTrain.readTheEncoder() < 2900) {
    			robotDrive41.drive(-0.3, -angle * kp);
    		}
    		if(Robot.driveTrain.readTheEncoder() > 3150) {
    			robotDrive41.drive(0.3, angle * kp);
    		}
    		if(Robot.driveTrain.readTheEncoder() > 2900 && Robot.driveTrain.readTheEncoder() < 3150) {
    			robotDrive41.drive(0, angle * kp);
    		}
    	}
    
    // Shifting Pnuematics
    
    	// These commands are used to shift to either high or low gear.
    	public void shiftToLowGear() {
    		shiftingSol.set(Value.kReverse);
    	}
    
    	public void shiftToHighGear() {
    		shiftingSol.set(Value.kForward);
    	}
    	
    // Climbing Control Loops
    	
    	// Under this winch command, the motor can not run unless the right trigger of our controller is fully 
    	// depressed. 
    	public void runTheWinch() {
    		if (Robot.oi.driverJoy.getRawAxis(3) == 1){
    			robotDrive41.drive(1, 0);
    		}
    	}
}
