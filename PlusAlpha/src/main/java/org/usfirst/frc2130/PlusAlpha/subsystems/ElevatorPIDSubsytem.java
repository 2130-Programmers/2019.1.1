// RobotBuilder Version: 2.0 
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2130.PlusAlpha.subsystems;

import org.usfirst.frc2130.PlusAlpha.Robot;
import org.usfirst.frc2130.PlusAlpha.RobotMap; 
import org.usfirst.frc2130.PlusAlpha.commands.*;
import edu.wpi.first.wpilibj.command.PIDSubsystem;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.DoubleSolenoid.Value;

import com.ctre.phoenix.motorcontrol.FeedbackDevice;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.PIDSourceType;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class ElevatorPIDSubsytem extends PIDSubsystem {
	
	public static final int kPIDLoopIdx = 0;
	double lastMeasurement = 0;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final DoubleSolenoid elevatorSolenoid = RobotMap.elevatorPIDSubsytemelevatorSolenoid;
    private final Encoder nullEncoder = RobotMap.elevatorPIDSubsytemnullEncoder;
    private final WPI_TalonSRX elevatorMotor = RobotMap.elevatorPIDSubsytemelevatorMotor;
    private final WPI_TalonSRX elevatorSlaveMotor = RobotMap.elevatorPIDSubsytemelevatorSlaveMotor;
    private final DigitalInput topProx = RobotMap.elevatorPIDSubsytemtopProx;
    private final DigitalInput bottomProx = RobotMap.elevatorPIDSubsytembottomProx;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // Initialize your subsystem here
    public ElevatorPIDSubsytem() {
    	/*
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
        super("ElevatorPIDSubsytem", 2.5E-4, 0.0, 0.0);
        setAbsoluteTolerance(0.2);
        getPIDController().setContinuous(false);
        LiveWindow.addActuator("ElevatorPIDSubsytem", "PIDSubsystem Controller", getPIDController());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
     */
    	
    	/* I commented out the auto generated code above. Rather than having to remember to change robot builder every
    	 * time that we played with these values, it'll be easier to change them here. That said, don't change
    	 * robot builder PID values and expect to see a change here. */
    	super("ElevatorPIDSubsytem", 0.00013, 0.0, 0.0);
        setAbsoluteTolerance(200);
        getPIDController().setContinuous(false);
        LiveWindow.addActuator("ElevatorPIDSubsytem", "PIDSubsystem Controller", getPIDController());

        // Use these to get going:
        // setSetpoint() -  Sets where the PID controller should move the system
        //                  to
        // enable() - Enables the PID controller.
    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    	
    	setDefaultCommand(new JoystickElevatorController());
    }

    @Override
    protected double returnPIDInput() {
        // Return your input value for the PID loop
        // e.g. a sensor, like a potentiometer:
        // yourPot.getAverageVoltage() / kYourMaxVoltage;
    	/*
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
        return nullEncoder.pidGet();

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
     */
    	double alpha = 0.0363295212;
    	
    	double output = alpha * elevatorHeight() + (1 - alpha) * lastMeasurement;
    	lastMeasurement = elevatorHeight();
    	
    	return output;
    }

    @Override
    protected void usePIDOutput(double output) {
        // Use output to drive your system, like a motor
        // e.g. yourMotor.set(output);
    	
    	elevatorMotor.pidWrite(output);
    	
       /* // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
        elevatorMotor.pidWrite(output);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
     * */
    }
    
    public void brakeState(String state) {
    	switch(state) {
    	case("engaged"):
    		elevatorSolenoid.set(Value.kForward);
    	break;
    	case("disengaged"):
    		elevatorSolenoid.set(Value.kReverse);
    	break;
    	}
    }
    
    public void engageBrake() {
    	brakeState("engaged");
    }
    
    public void disengageBrake() {
    	brakeState("disengaged");
    }
    
    /* Sets the value of the talon encoder at its given position as its new 0 */
    public void zeroTheTalon() {
    	elevatorMotor.setSelectedSensorPosition(0, kPIDLoopIdx, 0);
    }
    
    /* Gives us the height of the elevator in ticks */
    public double elevatorHeight() {
    	 return 1 * elevatorMotor.getSelectedSensorPosition(0); // For bot 1
    	 //return -1 * elevatorMotor.getSelectedSensorPosition(0); // For bot 2
    }
    
    /* The following function is used in our code to check whether or not the prox is active. Setting the boolean value
     * to true will tell the computer we're looking for the top prox, and false will tell it the bottom */
    public boolean getProx(boolean useTopProx) {
    	if (useTopProx) {
    		return !topProx.get();
    	} else {
    		return !bottomProx.get();
    	}
    }
    
    /* This tells us the output of the Talon, and whether its in the forward or backward direction */
    public double motorOutput() {
    	return elevatorMotor.getMotorOutputPercent();
    }
    
    public void resetpeakoutput() {
    	elevatorMotor.configPeakOutputForward(1, 0);
    	elevatorMotor.configPeakOutputReverse(-1, 0);
    }
   
    /* The following function will run our elevator to several desired setpoints, activating a pnuematic
     * break when it reaches its destination */
    public void setSetpointWithBrake(int setpoint) {    
    	/* This code functions as a sort of dampener. When the elevator is below a certain point it slows down and
    	 * gently parks at the bottom prox */
    	if (elevatorHeight() < 4000) {
    		elevatorMotor.configPeakOutputForward(0.7, 0);
    		elevatorMotor.configPeakOutputReverse(-0.2, 0);
    	}
    	if (elevatorHeight() >= 4000) {
    		elevatorMotor.configPeakOutputForward(0.7, 0);
    		elevatorMotor.configPeakOutputReverse(-0.43, 0);
    	}
    	
    	if(motorOutput() > 0 && getProx(true) == true) {
    		disable();
    		elevatorMotor.set(0);
    	}
    	if(motorOutput() < 0 && getProx(false) == true) {
    		disable();
    		elevatorMotor.set(0);
    	}
    	
    	/* Currently this gives our loop a tolerance of 10 native encoder units. Once we are within this range,
    	 * the brake will engage and the loop will end, holding us position until a new setpoint is called*/
    	if(elevatorHeight() > setpoint - 500 && elevatorHeight() < setpoint + 500 && elevatorHeight() > 1000) {
    		disable();
    		brakeState("engaged");
    		stopAllMotors();
    	}
    	else {
    		enable();
    		brakeState("disengaged");
    		setSetpoint(setpoint);
    	}
    	
    	if(elevatorHeight() < setpoint && elevatorHeight() <= 1000 && motorOutput() < 0) {
    		disable();
    		stopAllMotors();
    	}
    }
    
    /* This zeroes out our elevator each time it hits the bottom prox, which will keep its setpoints accurate
     * over the course of a while match */
    public void homeEncoder() {
    	if (getProx(false) == true) {
    	    zeroTheTalon();
    	}
    }
    
    public void elevatorManualControl() {
    	resetpeakoutput();
    	elevatorMotor.set(Robot.oi.operatorJoystick.getRawAxis(1));
    }
    
    /* This stops all of the motors */
    public void stopAllMotors() {
    	elevatorMotor.stopMotor();
    }
}
